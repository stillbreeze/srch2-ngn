/*
 * Copyright (c) 2016, SRCH2
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *    * Neither the name of the SRCH2 nor the
 *      names of its contributors may be used to endorse or promote products
 *      derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL SRCH2 BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * ULEB128.cpp
 *
 *  Created on: Sep 2, 2013
 */

#include "ULEB128.h"
#include "util/Logger.h"
#ifndef NULL
#define NULL 0
#endif

namespace srch2 {
namespace util {
/*
 *  Converts array of unsigned 32 bit integers to variable length byte array in two steps.
 *  1- perform delta encoding of input numbers
 *  2- convert delta encoded numbers to VLB array
 *
 *  For more detail visit:
 *    http://en.wikipedia.org/wiki/Variable-length_quantity
 *    https://srch2inc.atlassian.net/wiki/pages/viewpage.action?pageId=5144602
 *
 */
int ULEB128::uInt32VectorToVarLenArray (const std::vector<unsigned>& positionList, uint8_t** buffer) {

    if (positionList.size() == 0)
        return 0;

    std::vector<uint8_t> tempBuffer;
    tempBuffer.reserve(1.5 * positionList.size());
    uint8_t buf[5];
    short len;
    uInt32ToVarLengthBytes(positionList[0], buf, &len);
    for (int j = 0; j < len; ++j){
        tempBuffer.push_back(buf[j]);
    }

    for (unsigned i = 1; i < positionList.size(); ++i) {
        uInt32ToVarLengthBytes(positionList[i] - positionList[i - 1], buf, &len);
        for (int j = 0; j < len; ++j)
            tempBuffer.push_back(buf[j]);
    }

    uint8_t *vlb = new uint8_t[tempBuffer.size()];
    for (unsigned i = 0; i< tempBuffer.size(); ++i)
        vlb[i] = tempBuffer[i];

    *buffer = vlb;
    return tempBuffer.size();
}
/*
 *  Converts variable length byte array to array of unsigned 32 bit integers in two steps.
 *  1- Converts VLB array to delta encoded numbers
 *  2 -Performs reverse delta encoding to get final output
 *
 */
void ULEB128::varLenByteArrayToInt32Vector (uint8_t* buffer, unsigned size,
		vector<unsigned>& positionList) {

	if (size == 0) {
		return;
	}

    if (*(buffer + size - 1) & 0x80) {
        Logger::error("buffer has bad encoding..last byte is not a terminating one");
        return;
    }

    unsigned firstValue;
    short byteRead = 0;
    unsigned offset = 0;

    varLengthBytesToUInt32(buffer, &firstValue, &byteRead);
    positionList.push_back(firstValue);
    offset += byteRead;

    unsigned delta;
    while(offset < size) {
        varLengthBytesToUInt32(buffer + offset, &delta, &byteRead);
        unsigned previousValue = positionList.back();
        positionList.push_back(previousValue + delta);
        offset += byteRead;
    }
}
/*
 *  Converts unsigned 32 bit integer to variable length byte
 */
bool ULEB128::uInt32ToVarLengthBytes (unsigned position, uint8_t* varLenByteBuffer, short * length) {

    if (varLenByteBuffer == NULL || length  == NULL)
        return false;
    /*
     *  Note: the code below can be written as for loop but I chose to unroll the loop
     *  for better performance. Just not relying on compiler to do it for me.. other
     *  implementation on web also choose similar approach
     */

    *length = 0;
    // 7 bits
    uint8_t pos = (uint8_t)(position & 0x7F);
    *varLenByteBuffer=pos;
    (*length)++;
    position >>= 7;
    if (position == 0)
        return true;

    //14 bits
    (*varLenByteBuffer++) |= 0x80;
    pos = (uint8_t)(position & 0x7F);
    *varLenByteBuffer=pos;
    (*length)++;
    position >>= 7;
    if (position == 0)
        return true;

    //21 bits
    (*varLenByteBuffer++) |= 0x80;
    pos = (uint8_t)(position & 0x7F);
    *varLenByteBuffer=pos;
    (*length)++;
    position >>= 7;
    if (position == 0)
        return true;

    //28 bits
    (*varLenByteBuffer++) |= 0x80;
    pos = (uint8_t)(position & 0x7F);
    *varLenByteBuffer=pos;
    (*length)++;
    position >>= 7;
    if (position == 0)
        return true;

    // remaining bits
    (*varLenByteBuffer++) |= 0x80;
    pos = (uint8_t)(position & 0x7F);
    *varLenByteBuffer=pos;
    (*length)++;

    if (position>>=7 == 0)
        return -1;
    else
        return true;
}

/*
 *  Converts variable length byte to unsigned 32 bit integer.
 */

bool ULEB128::varLengthBytesToUInt32 (const uint8_t* varLenByteBuffer, unsigned* value, short* byteRead) {

    if (varLenByteBuffer == NULL || value == NULL || byteRead == NULL)
        return false;

    /*
     *  Note: the code below can be written as for loop but I chose to unroll the loop
     *  for better performance. Just not relying on compiler to do it for me.. other
     *  implementation on web also choose similar approach
     */

    short i = 0;
    unsigned& val = *value;
    // set 1-7
    val = varLenByteBuffer[i] & 0x7F;
    if (!(varLenByteBuffer[i++] & 0x80)) { *byteRead = i; return true; }
    // set 8-14
    val =  val | (varLenByteBuffer[i] & 0x7F) << 7;
    if (!(varLenByteBuffer[i++] & 0x80)) { *byteRead = i; return true; }
    // set 15-21
    val =  val | (varLenByteBuffer[i] & 0x7F) << 14;
    if (!(varLenByteBuffer[i++] & 0x80)) { *byteRead = i; return true; }
    // set 22-28
    val =  val | (varLenByteBuffer[i] & 0x7F) << 21;
    if (!(varLenByteBuffer[i++] & 0x80)) { *byteRead = i; return true; }
    // remaining
    val =  val | (varLenByteBuffer[i] & 0x7F) << 28;
    if (varLenByteBuffer[i++] & 0x80) {
        return false;  // fatal error : expeciting 32 bit integer encoding.
    }
    else {
        *byteRead = i; return true;
    }
}
}
}
