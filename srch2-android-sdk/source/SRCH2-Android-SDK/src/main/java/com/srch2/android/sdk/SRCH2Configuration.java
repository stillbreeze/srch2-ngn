/*
 * Copyright (c) 2016, SRCH2
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *    * Neither the name of the SRCH2 nor the
 *      names of its contributors may be used to endorse or promote products
 *      derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL SRCH2 BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.srch2.android.sdk;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.io.UnsupportedEncodingException;
import java.math.BigInteger;
import java.security.SecureRandom;
import java.util.ArrayList;
import java.util.HashMap;

final class SRCH2Configuration {

    static final String TAG = "SRCH2Configuration";


    static final String SRCH2_HOME_FOLDER_DEFAULT_NAME = "srch2/";
    static final String HOSTNAME = "127.0.0.1";

    private static final String DEFAULT_VALUE_logLevel = "3";
    private static final String DEFAULT_VALUE_accessLogFile = "srch2-log.txt";


    private String fullPathOfSRCH2home = "srch2";
    private int maxSearchThreads = 1;
    private int port = 8081;
    private String authorizationKey ;

    final HashMap<String, IndexableCore> indexableMap = new HashMap<String, IndexableCore>();

    /** Note is used by the xml configuration file relative to SRCH2Home by SQLiteConnector: hence we go up
     * two directories as /data/data/apppath/files/srch2 is home but databases is in /data/data/apppath/databases  */
    private String relativeDatabasePath = "../../databases";
    String getAppDatabasePath() {
        return relativeDatabasePath;
    }
    /** Note is used by the xml configuration file relative to SRCH2Home by SQLiteConnector: hence we go up
     * two directories as /data/data/apppath/files/srch2 is home but bin is in /data/data/apppath/bin  */
    private String relativeBinPath = "../../bin";
    String getAppBinDirectory() {
        return relativeBinPath;
    }

    /** Used only during configuration initialization: is dereferenced after initialization is finished. */
    ArrayList<String> uniqueTableNameList = new ArrayList<String>();

    /**
     * It returns the SRCH2Home, path where engine stores the serialized files.
     * @return the full path of SRCH2 home
     */
    String getSRCH2Home() {
        return fullPathOfSRCH2home;
    }

    /**
     * This value specifies the path of a folder where the engine stores.
     * serialized index files.
     */
    void setSRCH2Home(String appHomeDirectory) {
        fullPathOfSRCH2home = appHomeDirectory + File.separator + SRCH2Configuration.SRCH2_HOME_FOLDER_DEFAULT_NAME;
    }

    /**
     * It returns the port to which the engine is bound.
     * @return the port number of the server
     */
    int getPort() {
        return port;
    }

    /**
     * It sets the port of the local machine to which the engine is bound.
     * @param port the port number
     */
    void setPort(int port) {
        this.port = port;
    }

    String getAuthorizationKey() { return this.authorizationKey; }

    String getUrlString() {
        return "http://" + HOSTNAME + ":" + getPort() + "/";
    }

    /**
     * Specifies the authorization key that enables access to the SRCH2 search server. This way
     * the SRCH2 search server will only respond to valid clients. If this method is not called and
     * the authorication key is not explicitly set, one will be generated by the <code>SRCH2Engine</code>.
     * <br><br>
     * Once this method is called and the authorization key explicitly set, any RESTful request of the
     * SRCH2 search server must contain in the HTTP URL the following key-value pair of the form:
     * OAuth=foobar
     * to validate the RESTful request for the SRCH2 search server.
     * <br><br>
     * Example: curl -i "http://localhost:8081/search?q=terminator&OAuth=foobar"
     *
     * @param authorizationKey the auth key
     */
    void setAuthorizationKey(String authorizationKey) {
        if (authorizationKey == null) {
            throw new NullPointerException("Authorization key cannot be null");
        }
        this.authorizationKey = authorizationKey;
    }

    SRCH2Configuration(ArrayList<IndexableCore> indexes) {
        Class<?> c = null;
        if (indexes != null) {
            for (IndexableCore idx : indexes) {
                c = idx.getClass();
                if (Indexable.class.isAssignableFrom(c)) {
                    validateIndexable((Indexable) idx);
                    idx.indexInternal = createIndex(new IndexDescription((Indexable) idx));
                } else if (SQLiteIndexable.class.isAssignableFrom(c)) {
                    Schema s = ((SQLiteIndexable) idx).getSchema();
                    validateSqliteIndexable((SQLiteIndexable) idx, s);
                    idx.indexInternal = createIndex(new IndexDescription((SQLiteIndexable) idx, s));
                }
                indexableMap.put(idx.getIndexName(), idx);
            }
        }
        uniqueTableNameList = null;
    }

    IndexInternal createIndex(IndexDescription indexDescription) {
        IndexInternal indexInternal = new IndexInternal(indexDescription);
        checkIfIndexNameValidAndAlreadyExistedThrowIfNot(indexDescription.getIndexName());
        return indexInternal;
    }

    void validateSRCH2Index(IndexableCore indexable, Schema idxSchema) {
        if (indexable == null) {
            throw new NullPointerException("Cannot onResume the SRCH2Engine when a null Indexable is passed.");
        }
        IndexDescription.throwIfNonValidIndexName(indexable.getIndexName());

        if (idxSchema == null) {
            throw new NullPointerException("Indexable " + indexable.getIndexName() + " cannot be initialized with null schema: verify getSchema() is returning a valid schema object.");
        }

        if (indexable.getHighlighter() == null) {
            throw new NullPointerException("Indexable " + indexable.getIndexName() + " cannot be initialized with null highlighter: verify getHighlighter() is returning a valid highlighter object.");
        }
        IndexDescription.throwIfNonValidFuzzinessSimilarityThreshold(indexable.getFuzzinessSimilarityThreshold());
        IndexDescription.throwIfNonValidTopK(indexable.getTopK());
    }

    void validateIndexable(Indexable indexable) {

        validateSRCH2Index((IndexableCore) indexable, indexable.getSchema());
    }

    void validateSqliteIndexable(SQLiteIndexable indexable, Schema s) {
        validateSRCH2Index((IndexableCore) indexable, s);
        checkIfDatabaseNameValidThrowIfNot(indexable.getDatabaseName());
        checkIfDatabaseTableNameValidThrowIfNot(indexable.getTableName());
    }

    void checkIfDatabaseNameValidThrowIfNot(String databaseName) {
        if (databaseName == null) {
            throw new NullPointerException("Cannot pass null database name.");
        } else if (databaseName.length() < 1) {
            throw new IllegalArgumentException("Cannot pass empty string as databaseName.");
        }
    }

    void checkIfDatabaseTableNameValidThrowIfNot(String tableName) {
        if (tableName == null) {
            throw new NullPointerException("Cannot pass null tableName.");
        } else if (tableName.length() < 1) {
            throw new IllegalArgumentException("Cannot pass empty string as tableName.");
        } else if (uniqueTableNameList.contains(tableName)) {
            throw new IllegalArgumentException("The string tableName already existed.");
        } else {
            uniqueTableNameList.add(tableName);
        }
    }

    void checkIfIndexNameValidAndAlreadyExistedThrowIfNot(String indexName) {
        if (indexName == null) {
            throw new NullPointerException("Cannot pass null indexName.");
        } else if (indexName.length() < 1) {
            throw new IllegalArgumentException("Cannot pass empty string as indexName.");
        } else if (indexableMap.containsKey(indexName)) {
            throw new IllegalArgumentException("The string indexName already existed.");
        }
    }

    void checkIfIndexNameValidAndThrowIfNot(String indexName) {
        if (indexName == null) {
            throw new NullPointerException("Cannot pass null indexName.");
        } else if (indexName.length() < 1) {
            throw new IllegalArgumentException("Cannot pass empty string as indexName.");
        } else if (!indexableMap.containsKey(indexName)) {
            throw new IllegalArgumentException("The string indexName must correspond to the name of Indexable passed into SRCH2Configuration upon SRCH2Engine.initialization(...).");
        }
    }

    Indexable getIndexableAndThrowIfNotThere(String name) {
        checkIfIndexNameValidAndThrowIfNot(name);
        IndexableCore idx = indexableMap.get(name);
        if (!Indexable.class.isAssignableFrom(idx.getClass())) {
            throw new IllegalArgumentException("The value of the string name: " + name + " does not match any Indexable.");
        }
        return (Indexable) idx;
    }

    SQLiteIndexable getSqliteIndexableAndThrowIfNotThere(String name) {
        checkIfIndexNameValidAndThrowIfNot(name);
        IndexableCore idx = indexableMap.get(name);
        if (!SQLiteIndexable.class.isAssignableFrom(idx.getClass())) {
            throw new IllegalArgumentException("The value of the string name: " + name + " does not match any SqliteIndexable.");
        }
        return (SQLiteIndexable) idx;
    }

    /** generates the configuration file literal that will be passed to the SRCH2Service */
    static String generateConfigurationFileString(SRCH2Configuration conf) {
        if (conf.indexableMap.size() == 0) {
            throw new IllegalStateException("No index provided");
        }




        String defaultIndexName = conf.indexableMap.values().iterator().next().getIndexName();
        StringBuilder configurationXML = new StringBuilder()
            .append("<config>\n\n")
            .append(IndexDescription.TAB_SINGLE).append("<srch2Home>").append(conf.fullPathOfSRCH2home).append("</srch2Home>\n")
            .append(conf.getAuthorizationKeyConfigurationNode())
            .append(IndexDescription.TAB_SINGLE).append("<listeningHostname>").append(HOSTNAME).append("</listeningHostname>\n")
            .append(IndexDescription.TAB_SINGLE).append("<listeningPort>").append(conf.getPort()).append("</listeningPort>\n")
            .append(IndexDescription.TAB_SINGLE).append("<heartBeatTimer>")
                        .append(String.valueOf(IPCConstants.HEART_BEAT_SERVER_CORE_SHUTDOWN_DELAY_SECONDS))
            .append("</heartBeatTimer>\n")
            .append(IndexDescription.TAB_SINGLE).append("<maxSearchThreads>").append(conf.maxSearchThreads).append("</maxSearchThreads>\n")
            .append(IndexDescription.TAB_SINGLE).append("<cores defaultCoreName=\"").append(defaultIndexName).append("\">\n\n");

        for (IndexableCore idxable : conf.indexableMap.values()) {
            configurationXML.append(idxable.indexInternal.getConf().indexStructureToXML()).append("\n");

        }

        configurationXML
            .append(IndexDescription.TAB_SINGLE)
                .append("</cores>\n")
            .append(IndexDescription.TAB_SINGLE)
                .append("<updateLog>\n")
            .append(IndexDescription.TAB_DOUBLE)
                .append("<logLevel>")
                    .append(DEFAULT_VALUE_logLevel)
                .append("</logLevel>\n")
            .append(IndexDescription.TAB_DOUBLE)
                .append("<accessLogFile>")
                    .append(DEFAULT_VALUE_accessLogFile)
                .append("</accessLogFile>\n")
            .append(IndexDescription.TAB_SINGLE)
                .append("</updateLog>\n")
            .append("</config>\n");
        return configurationXML.toString();
    }

    private String getAuthorizationKeyConfigurationNode() {
        StringBuilder auth = new StringBuilder();
        if (authorizationKey == null) {
            authorizationKey = generateAuthorizationKey();
        }
        auth.append(IndexDescription.TAB_SINGLE)
                .append("<authorization-key>").append(this.authorizationKey).append("</authorization-key>\n");
        return auth.toString();

    }

    private String generateAuthorizationKey() {
        SecureRandom random = new SecureRandom();
        return new BigInteger(130, random).toString(32);
    }

    /** dumps the configuration file to the specified destination */
    void writeConfigurationFileToDisk(String destinationDiskPath) throws FileNotFoundException,
            UnsupportedEncodingException {
        PrintWriter writer = new PrintWriter(destinationDiskPath, "UTF-8");
        writer.println(generateConfigurationFileString(this));
        writer.close();
    }
}
